<html>
<head>
<script language="Javascript">

// =============== GLOBALS ==============

// Bookmarked page database
var SearchMarkDB = {};

// Contains bookmarks added to the database
// Only used during first initialization after that
// its empty.
var gProcessedUrls = [];
var gRemainingSearch = 0;

// During each search, the keywords are placed here.
var gSearchRegex = "";
var gSearchKeywords = "";
var gContextLen = 200;

// Communicate with extension UI
var gPort;

// Note to self. Why I need the above global variable:
// In the current state of the database API, if I search
// it, then the results don't contain any info about
// what was searched. This is due to the async callbacks
// that return the result. If callbacks were more 
// thoughtfully designed, they would allow one to pass 
// some private information to it, that is sent back when 
// the callback is called. The whole reason behind this 
// extra argument is that callbacks cause a state change: 
// from the function you are in, to the callback itself.
// But, I don't want to loose the previous state, maybe
// I had arguments to the function that called the function
// that initiated a callback that I need to use to process 
// the results from the callback. But now, I am
// forced be in the callback where I don't have that info
// anymore. The key idea: when designing a callback allow
// some state to be registered with it.

// ======================== DATABASE API ==================

// Open the database
SearchMarkDB.db = null;
SearchMarkDB.open = function() {
    var dbSize = 200 * 1024 * 1024; // 200 MB
    SearchMarkDB.db = openDatabase('SearchMarkDB', 
                                   '1.0', 'Bookmark Page Storage', 
                                   dbSize);
}

// Error and success callbacks
SearchMarkDB.onErrorCb = function(tx, e) {
    console.log(e.message);
}

SearchMarkDB.onAddCb = function(tx, r) {
    console.log("Added. " + gProcessedUrls.pop());
}

SearchMarkDB.onRemoveCb = function(tx, r) {
    console.log("Removed. " + gProcessedUrls.pop());
}

SearchMarkDB.onUpdateCb = function(tx, r) {
    console.log("Updated. " + gProcessedUrls.pop());
}

SearchMarkDB.onClearCb = function(tx, r) {
    console.log("Cleared SearchMark database.");
}

SearchMarkDB.onDeleteCb = function(tx, r) {
    console.log("Deleted SearchMark database table 'pages'.");
}

SearchMarkDB.onCreateTableCb = function(tx, r) {
    console.log("Created SearchMark database table 'pages'.");
}

// special callback to print all the bookmark
// URLs once they are retrieved from the database.
SearchMarkDB.showAllBookmarksCb = function(tx, r) {
    for(var i = 0; i < r.rows.length; i++) {
        console.log("Stored. " + r.rows.item(i).url);
    }
}

// Deprecated. Used for debugging only.
// Show search results.
SearchMarkDB.debugSearchPageCb = function(tx, rs) {
    for(var i = 0; i < rs.rows.length; i++) {
        console.log(rs.rows.item(i).url);
    }
}

// create the table that stores all the bookmark
// info, including the associated pages.
SearchMarkDB.createTable = function() {
    SearchMarkDB.db.transaction(function(tx) {
        tx.executeSql('CREATE TABLE IF NOT EXISTS ' 
                      + 'pages(id INTEGER PRIMARY KEY, ' 
                      + 'url TEXT, title TEXT, page TEXT, ' 
                      + 'htmlpage TEXT)', 
                      [],
                      SearchMarkDB.onCreateTableCb,
                      SearchMarkDB.onErrorCb);
    });
}

// add a bookmark and associated page to the database
SearchMarkDB.addBookmarkedPage = 
    function(newId, newUrl, newTitle, newPlainPage, newHtmlPage) {
        SearchMarkDB.db.transaction(function(tx){
            tx.executeSql('INSERT INTO pages(id, url, title, '
                          + 'page, htmlpage) ' 
                          + 'VALUES (?,?,?,?,?)', 
                          [newId, newUrl, newTitle, 
                           newPlainPage, newHtmlPage],
                          SearchMarkDB.onAddCb,
                          SearchMarkDB.onErrorCb);
        });
    }

// remove a bookmarked page from the database
SearchMarkDB.removeBookmarkedPage = 
    function(theId) {
        SearchMarkDB.db.transaction(function(tx){
            tx.executeSql('DELETE FROM pages WHERE id=?'
                          [theId],
                          SearchMarkDB.onRemoveCb,
                          SearchMarkDB.onErrorCb);
        });
    } 
    
// update an already stored bookmarked page
SearchMarkDB.updateBookmarkedPage = 
    function(theId, theUrl, theTitle, thePlainPage, theHtmlPage) {
        SearchMarkDB.db.transaction(function(tx){
            tx.executeSql('UPDATE pages SET url=?, '
                          + 'title=?, page=?, htmlpage=? ' 
                          + 'WHERE id=?', 
                          [theUrl, theTitle, thePlainPage,
                           theHtmlPage, theId],
                          SearchMarkDB.onUpdateCb,
                          SearchMarkDB.onErrorCb);
        });
    }

// get a page given the bookmark id
SearchMarkDB.getPage = function(id, callback) {
    SearchMarkDB.db.transaction(function(tx) {
        tx.executeSql('SELECT * FROM pages WHERE id = ' + id,
                      [],
                      callback,
                      SearchMarkDB.onErrorCb);
    });
}

// get all bookmark URLs. Callback function can
// be provided use the results as necessary.
SearchMarkDB.getStoredBookmarks = 
    function(callback) {
        SearchMarkDB.db.transaction(function(tx) {
            tx.executeSql('SELECT id,url,title FROM pages', 
                          [], 
                          callback,
                          SearchMarkDB.onErrorCb);
        });
    }

// Deprecated. Although simple to implement, this does
// not tell us where in a page a match for the keywords was
// found. We only know which pages matched. To show context 
// in the search results, we need the start index of the match, 
// and for that, the keyword search will have to be repeated on 
// all returned pages. This coupled with the fact this function
// uses a lot of memory -- all results are returned at once
// with entire pages -- makes it not very viable.
//
// A better function will retrieve a page at a time,
// search once per page, and then release that memory
// before moving on. This is probably scalable to a
// couple of thousand bookmarks, which should be enough
// for the purposes of this extension.
SearchMarkDB.debugSearch = 
    function(keywords, callback) {
        SearchMarkDB.db.transaction(function(tx) {
            var searchTxt = "'%" + keywords + "%'";
            tx.executeSql("SELECT url FROM pages WHERE "
                          + "page LIKE " + searchTxt + " OR " 
                          + "url LIKE " + searchTxt,
                          [],
                          callback, 
                          SearchMarkDB.onErrorCb);
        });
    }

// clear all stored information.
SearchMarkDB.clear = function() {
    SearchMarkDB.db.transaction(function(tx) {
        tx.executeSql('DELETE FROM pages', [],
                      SearchMarkDB.onClearCb,
                      SearchMarkDB.onErrorCb);
    });
}

// remove the table and all stored information
SearchMarkDB.purge = function() {
    SearchMarkDB.db.transaction(function(tx) {
        tx.executeSql('DROP TABLE pages', 
                      [],
                      SearchMarkDB.onDeleteCb,
                      SearchMarkDB.onErrorCb);
    });
}

// ================== INIT ===============

// open the database each time extension loads.
SearchMarkDB.open();
console.debug("Opened SearchMark database.");

// SearchMarkDB.getStoredBookmarks(SearchMarkDB.showAllBookmarksCb);
// SearchMarkDB.purge();
// SearchMarkDB.clear();
//localStorage['initialized'] = "no";

// initialize once only. Populate the database
// by retrieving and storing bookmarked pages, and
// URLs. If initialized but want to reinitialize,
// just set localStorage['initialized'] to "no".
if(!localStorage['initialized'] ||
   localStorage['initialized'] != "yes") {
    SearchMarkDB.createTable();

    chrome.bookmarks.getTree(function(bookmarks) {
        initBookmarkDatabase(bookmarks);
    });

    localStorage['initialized'] = "yes";
    
    console.debug("Saving Bookmarked pages to SearchMark database.");
}

// ========================== CORE ===============

chrome.browserAction.onClicked.addListener(
    function(tab) {
        chrome.tabs.create(
            {'url':'SearchMarkUI.html'},
            function(newTab) {});
    });

chrome.extension.onRequest.addListener(
    function(request, sender, callback) {
        // Deprecated. Using only for debugging.
        // See note on DB.debugSearch
        if(request.method == 'debugSearch') {
            SearchMarkDB.debugSearch(
                request.keywords,
                SearchMarkDB.debugSearchPageCb);
            
            callback('');
        } else if(request.method == 'search') {
            gSearchKeywords = request.keywords;

            gSearchRegex = new RegExp('(' + request.keywords + ')',
            'i');

            gPort = chrome.extension.connect({name: "uiToBackend"});

            searchBookmarkedPages();

            callback('');
        } else {
            callback('');
        }
    });

chrome.bookmarks.onChanged.addListener(
    function(id, changeInfo) {
        if(localStorage['initialized'] != "yes")
            return;

        getAndStoreBookmarkContent(
            {id: id, url: changeInfo.url, title: changeInfo.title},
            SearchMarkDB.updateBookmarkedPage);
    });

chrome.bookmarks.onCreated.addListener(
    function(id, newBookmark) {
        if(localStorage['initialized'] != "yes")
            return;

        getAndStoreBookmarkContent(
            {id: id, url: newBookmark.url, title: newBookmark.title},
            SearchMarkDB.addBookmarkedPage);
    });

chrome.bookmarks.onRemoved.addListener(
    function(id, removeInfo) {
        if(localStorage['initialized'] != "yes")
            return;

        gProcessedUrls.push(removeInfo.url);

        SearchMarkDB.removeBookmarkedPage(id);
    });

// ================= CORE API ===================

function informUIResultsDone()
{
    var result = {};

    result.matchType = "DONE";

    gPort.postMessage(result);

    // cleanup
    gSearchRegex = "";
    gSearchKeywords = "";
    gPort.disconnect();
}

function searchPageCb(tx, r) {
    for(var i = 0; i < r.rows.length; i++) {
        var matchIdx;

        if((matchIdx = 
            r.rows.item(i).page.search(gSearchRegex)) != -1) {
            var context = '';

            context = r.rows.item(i).page.substring(
                matchIdx - gContextLen, matchIdx + gContextLen);

            // Trim incomplete word from end.
            // We only look for whitespace until a third of
            // the context's length.
            for(var endIdx = context.length-1;
                endIdx > context.length - context.length/3; 
                --endIdx) 
            {
                if(context[endIdx] == ' ' && endIdx != context.length-1) {
                    context = context.slice(0, endIdx);
                    context = context.concat("...");
                    break;
                }
            }

            // now trim from beginning.
            for(var startIdx = 0; startIdx < context.length/3;
                ++startIdx) 
            {
                if(context[startIdx] == ' ' && startIdx != 0) {
                    context = context.slice(startIdx);
                    context = (new String("...")).concat(context);
                    break;
                }
            }

            // bold matched text
            context = context.replace(gSearchRegex, "<b>$1</b>");

            var result = {};

            result.url = r.rows.item(i).url;
            if(r.rows.item(i).title == undefined) {
                result.title = r.rows.item(i).url;
            } else {
                result.title = r.rows.item(i).title;
            }
            result.text = context;
            result.matchType = "page";

            gPort.postMessage(result);
        }

        gRemainingSearch--;
    }
    
    if(!gRemainingSearch) {
        informUIResultsDone();
    }
}

// 'r' is a list of all stored bookmark URLs
function searchBookmarkedPagesCb(tx, r) {
    gRemainingSearch = r.rows.length;

    for(var i = 0; i < r.rows.length; i++) 
    {
        if(r.rows.item(i).title &&
           r.rows.item(i).title.search(gSearchRegex) != -1) 
        { // handle Title matches here
            var result = {};

            result.url = r.rows.item(i).url;
            result.title = r.rows.item(i).title.replace(
                gSearchRegex, "<b>$1</b>");
            result.text = "";
            result.matchType = "title";

            gPort.postMessage(result);

            gRemainingSearch--;
        }
        else if(r.rows.item(i).url.search(gSearchRegex) != -1) 
        { // handle URL matches here
            var result = {};

            result.url = r.rows.item(i).url;
            if(r.rows.item(i).title == undefined) {
                result.title = r.rows.item(i).url;
            } else {
                result.title = r.rows.item(i).title;
            }
            result.text = r.rows.item(i).url.replace(
                gSearchRegex, "<b>$1</b>");
            result.matchType = "url";

            gPort.postMessage(result);

            gRemainingSearch--;
        } else { // handle Page matches here
            SearchMarkDB.getPage(r.rows.item(i).id,
                                 searchPageCb);
        }
    }

    if(!gRemainingSearch) {
        informUIResultsDone();
    }
}

function removeHTMLfromPage(page) {
    // reduce spaces, remove new lines
    var pagetxt = page.replace(/\s+/gm, " ");

    // remove 'script' and 'head' tags *and* content
    pagetxt = pagetxt.replace(
            /<\s*?head.*?>.*?<\s*?\/\s*?head\s*?>/i, " ");
    pagetxt = pagetxt.replace(
            /<\s*?script.*?>.*?<\s*?\/\s*?script\s*?>/gi, " ");
    pagetxt = pagetxt.replace(
            /<\s*?style.*?>.*?<\s*?\/\s*?style\s*?>/gi, " ");

    // Now remove other tags
    pagetxt = pagetxt.replace(/<.*?\/?>/g, " ");

    // Remove symbols
    pagetxt = pagetxt.replace(/&.*?;/g, " ");

    // Remove comment markers
    pagetxt = pagetxt.replace(/(<!--|-->)/g, " ");

    // After all the filtering, need to fix up spaces again
    pagetxt = pagetxt.replace(/\s+/gm, " ");

    return pagetxt;
}

function searchBookmarkedPages() {
    SearchMarkDB.getStoredBookmarks(searchBookmarkedPagesCb);
}

function getAndStoreBookmarkContent(bookmark, storeInDB) {
    try {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", bookmark.url, true);
        xhr.onreadystatechange = function() {
            try {
                if (xhr.readyState == 4) {

                    var pageNoHtml = 
                        removeHTMLfromPage(xhr.responseText);

                    // add page to database
                    storeInDB(bookmark.id, bookmark.url,
                              bookmark.title, pageNoHtml,
                              xhr.responseText);

                    gProcessedUrls.push(bookmark.url);
                }
            } catch(e) {
                console.log(e.message);
                storeInDB(bookmark.id, bookmark.url,
                          bookmark.title, "", "");
            }
        }

        xhr.send();
    } catch(e) {
        console.log(e.message + bookmark.url);
        storeInDB(bookmark.id, bookmark.url,
                  bookmark.title, "", "");
    }
}

function initBookmarkDatabase(bookmarks) {
    bookmarks.forEach(function(bookmark) {
        if(bookmark.url && bookmark.url.match("^https?://*")) 
        { // url exists and is well formed
            getAndStoreBookmarkContent(bookmark, 
                                       SearchMarkDB.addBookmarkedPage);
        } else {
            console.debug("Skipping. " + bookmark.url);
        }

        if (bookmark.children)
            initBookmarkDatabase(bookmark.children);
    });
}
</script>
</head>
</html>
