<html>
<head>
<script language="Javascript">

// =============== GLOBALS ==============

// Bookmarked page database
var SearchMarkDB = {};

// Contains bookmarks added to the database
// Only used during first initialization after that
// its empty.
var gAddedUrls = [];

// During each search, the keywords are placed here.
var gSearchRegex = "";
var gSearchKeywords = "";
var gContextLen = 100;

// Communicate with extension UI
var gPort;

// Note to self. Why I need the above global variable:
// In the current state of the database API, if I search
// it, then the results don't contain any info about
// what was searched. This is due to the async callbacks
// that return the result. If callbacks were more 
// thoughtfully designed, they would allow one to pass 
// some private information to it, that is sent back when 
// the callback is called. The whole reason behind this 
// extra argument is that callbacks cause a state change: 
// from the function you are in, to the callback itself.
// But, I don't want to loose the previous state, maybe
// I had arguments to the function that called the function
// that initiated a callback that I need to use to process 
// the results from the callback. But now, I am
// forced be in the callback where I don't have that info
// anymore. The key idea: when designing a callback allow
// some state to be registered with it.

// ======================== DATABASE API ==================

// Open the database
SearchMarkDB.db = null;
SearchMarkDB.open = function() {
    var dbSize = 200 * 1024 * 1024; // 200 MB
    SearchMarkDB.db = openDatabase('SearchMarkDB', 
                                   '1.0', 'Bookmark Page Storage', 
                                   dbSize);
}

// Error and success callbacks
SearchMarkDB.onErrorCb = function(tx, e) {
    console.log(e.message);
}

SearchMarkDB.onAddedCb = function(tx, r) {
    console.log("Added. " + gAddedUrls.pop());
}

SearchMarkDB.onClearCb = function(tx, r) {
    console.log("Cleared SearchMark database.");
}

SearchMarkDB.onDeleteCb = function(tx, r) {
    console.log("Deleted SearchMark database table 'pages'.");
}

SearchMarkDB.onCreateTableCb = function(tx, r) {
    console.log("Created SearchMark database table 'pages'.");
}

// special callback to print all the bookmark
// URLs once they are retrieved from the database.
SearchMarkDB.showAllBookmarksCb = function(tx, r) {
    for(var i = 0; i < r.rows.length; i++) {
        console.log("Stored. " + r.rows.item(i).url);
    }
}

// Deprecated. Used for debugging only.
// Show search results.
SearchMarkDB.searchPageCb = function(tx, rs) {
    for(var i = 0; i < rs.rows.length; i++) {
        console.log(rs.rows.item(i).url);
    }
}

// create the table that stores all the bookmark
// info, including the associated pages.
SearchMarkDB.createTable = function() {
    SearchMarkDB.db.transaction(function(tx) {
        tx.executeSql('CREATE TABLE IF NOT EXISTS ' 
                      + 'pages(id INTEGER PRIMARY KEY, ' 
                      + 'url TEXT, title TEXT, page TEXT, ' 
                      + 'htmlpage TEXT)', 
                      [],
                      SearchMarkDB.onCreateTableCb,
                      SearchMarkDB.onErrorCb);
    });
}

// add a bookmark to the database
SearchMarkDB.addBookmarkedPage = 
    function(newId, newUrl, newTitle, newPlainPage, newHtmlPage) {
        SearchMarkDB.db.transaction(function(tx){
            tx.executeSql('INSERT INTO pages(id, url, title, '
                          + 'page, htmlpage) ' 
                          + 'VALUES (?,?,?,?,?)', 
                          [newId, newUrl, newTitle, 
                           newPlainPage, newHtmlPage],
                          SearchMarkDB.onAddedCb,
                          SearchMarkDB.onErrorCb);
        });
    }

SearchMarkDB.getPage = function(id, callback) {
    SearchMarkDB.db.transaction(function(tx) {
        tx.executeSql('SELECT * FROM pages WHERE id = ' + id,
                      [],
                      callback,
                      SearchMarkDB.onErrorCb);
    });
}

// get all bookmark URLs. Callback function can
// be provided use the results as necessary.
SearchMarkDB.getStoredBookmarks = 
    function(callback) {
        SearchMarkDB.db.transaction(function(tx) {
            tx.executeSql('SELECT id,url FROM pages', 
                          [], 
                          callback,
                          SearchMarkDB.onErrorCb);
        });
    }

// Deprecated. Although simple to implement, this does
// not tell us where in a page a match for the keywords was
// found. We only know which pages matched.
//
// To show context in the search results, we need the
// start index of the match, and for that, the keyword
// search will have to be repeated on all returned
// pages. This coupled with the fact this function
// uses a lot of memory (all results returned at once
// with entire pages) makes the following function not
// very viable.
//
// A better function will retrieve a page at a time,
// search once per page, and then release that memory
// before moving on.
SearchMarkDB.searchBookmarkedPages = 
    function(keywords, callback) {
        SearchMarkDB.db.transaction(function(tx) {
            var searchTxt = "'%" + keywords + "%'";
            tx.executeSql("SELECT url FROM pages WHERE "
                          + "page LIKE " + searchTxt + " OR " 
                          + "url LIKE " + searchTxt,
                          [],
                          callback, 
                          SearchMarkDB.onErrorCb);
        });
    }

// clear all stored information.
SearchMarkDB.clear = function() {
    SearchMarkDB.db.transaction(function(tx) {
        tx.executeSql('DELETE FROM pages', [],
                      SearchMarkDB.onClearCb,
                      SearchMarkDB.onErrorCb);
    });
}

SearchMarkDB.purge = function() {
    SearchMarkDB.db.transaction(function(tx) {
        tx.executeSql('DROP TABLE pages', 
                      [],
                      SearchMarkDB.onDeleteCb,
                      SearchMarkDB.onErrorCb);
    });
}

// ================== INIT ===============

// open the database each time extension loads.
SearchMarkDB.open();
console.debug("Opened SearchMark database.");

// SearchMarkDB.getStoredBookmarks(SearchMarkDB.showAllBookmarksCb);
// SearchMarkDB.purge();
// SearchMarkDB.clear();
localStorage['initialized'] = "no";

// initialize once only. Populate the database
// by retrieving and storing bookmarked pages, and
// URLs. If initialized but want to reinitialize,
// just set localStorage['initialized'] to "no".
if(!localStorage['initialized'] ||
   localStorage['initialized'] != "yes") {
    SearchMarkDB.createTable();

    chrome.bookmarks.getTree(function(bookmarks) {
        getAndStoreBookmarkContents(bookmarks);
    });

    localStorage['initialized'] = "yes";
    
    console.debug("Saving Bookmarked pages to SearchMark database.");
}

// ========================== CORE ===============

chrome.extension.onRequest.addListener(
    function(request, sender, callback) {
        // Deprecated. Using only for debugging.
        // See note on DB.searchBookmarkedPages
        if(request.method == 'debugSearch') {
            SearchMarkDB.searchBookmarkedPages(
                request.keywords,
                SearchMarkDB.searchPageCb);
            
            callback('');
        } else if(request.method == 'search') {
            gSearchKeywords = request.keywords;
            gSearchRegex = new RegExp('(' + request.keywords + ')', 'i');
            gPort = chrome.extension.connect({name: "uiToBackend"});
            searchBookmarkedPages();
            callback('');
        } else {
            callback('');
        }
    });

// ================= CORE API ===================

function searchPageCb(tx, r) {
    for(var i = 0; i < r.rows.length; i++) {
        var matchIdx;

        if((matchIdx = 
            r.rows.item(i).page.search(gSearchRegex)) != -1) {
            var result = '';

            if(r.rows.item(i).title.match("Plum"))
                console.log(r.rows.item(i).page);

            result = r.rows.item(i).page.substring(
                matchIdx - gContextLen, matchIdx + gContextLen);

            // bold matched text
            result = result.replace(gSearchRegex, "<b>$1</b>");

            result = "<a href=" + r.rows.item(i).url + ">" +
                r.rows.item(i).title + "</a><br>" + result;
            
            gPort.postMessage(result);
        }
    }
}

// 'r' is a list of all stored bookmark URLs
function searchBookmarkedPagesCb(tx, r) {
    for(var i = 0; i < r.rows.length; i++) 
    { // handle URL and Title here.
        if(r.rows.item(i).url.search(gSearchRegex) != -1) {
            var line;

            line = r.rows.item(i).url.replace(gSearchRegex,
                                              "<b>$1</b>");

            line = "<a href=" + r.rows.item(i).url + ">" +
                line + "</a>";
            
            gPort.postMessage(line);
        } else { // handle page here
            SearchMarkDB.getPage(r.rows.item(i).id,
                                 searchPageCb);
        }
    }

    // cleanup. WRONG PLACE
//    gPort.disconnect();
//    gSearchRegex = '';
//    gSearchKeywords = '';
}

function searchBookmarkedPages() {
    SearchMarkDB.getStoredBookmarks(searchBookmarkedPagesCb);
}

function getAndStoreBookmarkContents(bookmarks) {
    bookmarks.forEach(function(bookmark) {
        if(bookmark.url && bookmark.url.match("^https?://*")) 
        { // url exists and is well formed
            try {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", bookmark.url, true);
                xhr.onreadystatechange = function() {
                    try {
                        if (xhr.readyState == 4) {

                            // reduce spaces, remove new lines
                            var pageNoHtml = 
                                xhr.responseText.replace(/\s+/gm, " ");

                            // remove meta, script, style, and head 
                            // tag *and* content.
                            pageNoHtml =
                                pageNoHtml.replace(/<\s*(head|meta|script|style)\s+.*?>.*?<\s*\/\s*(head|meta|script|style)\s*>/gi, "");

                            // Now remove other tags
                            pageNoHtml =
                                pageNoHtml.replace(/<.*?\/?>/gi, "");

                            // add page to databse
                            SearchMarkDB.addBookmarkedPage(
                                bookmark.id,
                                bookmark.url,
                                bookmark.title,
                                pageNoHtml,
                                xhr.responseText);
                            
                            gAddedUrls.push(bookmark.url);
                        }
                    } catch(e) {
                        console.log(e.message);
                        SearchMarkDB.addBookmarkedPage(
                            bookmark.id,
                            bookmark.url,
                            bookmark.title,
                            "",
                            "");
                    }
                }
                xhr.send();
            } catch(e) {
                console.log(e.message + bookmark.url);
                SearchMarkDB.addBookmarkedPage(
                    bookmark.id,
                    bookmark.url,
                    bookmark.title,
                    "",
                    "");
            }
        } else {
            console.debug("Skipping. " + bookmark.url);
        }

        if (bookmark.children)
            getAndStoreBookmarkContents(bookmark.children);
    });
}
</script>
</head>
</html>
